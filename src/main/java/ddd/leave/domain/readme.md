entity： 领域实体， 唯一的业务标识，持有自己的业务属性和业务行为

event： 领域事件  通过事件机制让业务解耦

repository: 转换层  将基础层查询信息转换成 业务对象或数据对象。
> 在我们日常的代码中，使用Repository模式是一个很简单，但是又能得到很多收益的事情。最大的收益就是可以彻底和底层实现解耦，让上层业务可以快速自发展。
>
> 我们假设现有的传统代码包含了以下几个类（还是用订单举例）：
>
>OrderDO
>
>OrderDAO
>
>可以通过以下几个步骤逐渐的实现Repository模式：
>
>生成Order实体类，初期字段可以和OrderDO保持一致
>
>生成OrderDataConverter，通过MapStruct基本上2行代码就能完成
>
>写单元测试，确保Order和OrderDO之间的转化100%正确
>
>生成OrderRepository接口和实现，通过单测确保OrderRepository的正确性
>
>将原有代码里使用了OrderDO的地方改为Order
>
>将原有代码里使用了OrderDAO的地方都改为用OrderRepository
>
>通过单测确保业务逻辑的一致性。
>
>Order实体类和其业务逻辑可以随意更改，每次修改你唯一需要做的就是变更一下Converter，已经和底层实现完全解藕了。

service : 领域服务层  封装领域业务功能，将一个业务功能整体描述， 聚合同类型实体或不同类型实体的业务逻辑处理，数据更新等

valueobject: 值对象，数据自校验对象，在业务中 需要数据自校验的定义封装

vo：我认为 entity对象实在不能没有数据库的数据，业务离不开数据的支撑，但是我们又不能耦合 数据库的返回字段，因此建立 对应
的映射信息，当然还有优化处理，至少我目前的认为 不能将 数据的字段 皆转换成 值对象，这样语义复杂且不符合实际运用。


  